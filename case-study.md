# Ход выполнения задачи (чеклист)

## [x] ProgressBar
Не даст реального прогресса итераций -- основная обработка будет ниже цикла по строкам

## Время работы программы в зависимости от размера обрабатываемого файла

### Первый эксперимент
| Кол-во строк | Время всего |                               Основной цикл |
|--------------|-------------|---------------------------------------------|
| 50 000       |  98.073135s | 2.661192   3.306939   5.968131 (  7.372683) |
| 20 000       |  16.392062s | 0.397323   0.424769   0.822092 (  0.937124) |
| 10 000       |   4.504078s | 0.105436   0.089809   0.195245 (  0.198037) |
|  5 000       |   1.516187s | 0.033380   0.024044   0.057424 (  0.059473) |
|  1 000       |   0.790593s | 0.003793   0.001045   0.004838 (  0.004884) |
|      0       |   0.731707s | 0.000015   0.000044   0.000059 (  0.000063) |

### Второй эксперимент
| Кол-во строк |                                      Время |
|--------------|--------------------------------------------|
| 0 |   0.922668   0.288691   1.211359 (  1.324844) |
| 100 |   1.385575   0.176036   1.561611 (  1.601957) |
| 200 |   0.873091   0.159030   1.032121 (  1.048620) |
| 500 |   1.326376   0.159917   1.486293 (  1.501805) |
| 1000 |   1.233477   0.155291   1.388768 (  1.405454) |
| 2000 |   1.278277   0.158152   1.436429 (  1.455170) |
| 5000 |   1.723858   0.178938   1.902796 (  1.932623) |
| 10000 |   4.101404   0.389020   4.490424 (  4.618255) |
| 20000 |  13.757011   1.013136  14.770147 ( 15.085536) |
| 50000 |  73.247726   4.196170  77.443896 ( 78.699456) |
| 100000 | 255.687697  12.584914 268.272611 (272.068167) |
| 200000 | 1125.481167  47.655070 1173.136237 (1193.100580) |

Видна степенная зависимость, с маленькой (1.32с) постоянной составляющей.
Можно логически предположить, что это время, затрачиваемое на чтение файла.
Однако оно относительно мало для большого числа строк, где видна
нарастающая деградация выполнения.

## [x] Построить и проанализировать отчёт ruby-prof в режиме Flat;
```
Total: 2.101405
Sort by: self_time

%self      total      self      wait     child     calls  name                           location
48.62      1.022     1.022     0.000     0.000      774   Array#select
34.13      0.717     0.717     0.000     0.000    10001   String#split
4.18      1.280     0.088     0.000     1.192       41  *Array#each

Total: 7.727716
Sort by: self_time

 %self      total      self      wait     child     calls  name                           location
 65.84      5.088     5.088     0.000     0.000     1536   Array#select                   
 18.03      1.393     1.393     0.000     0.000    20001   String#split                   
  9.55      6.240     0.738     0.000     5.502       41  *Array#each   
```
Видно, что идет множественный вызов `#select`, по коду при этом можно понять,
что входной файл обрабатывается каждый раз для нового пользователя.
Это можно считать слабым местом.

## [x] Построить и проанализировать отчёт ruby-prof в режиме Graph;
```
 	 	        4.30	0.03	0.00	4.27	2/41	    Object#work	    79
80.87%	7.32%	5.37	0.49	0.00	4.88	41      	*Array#each	
 	 	        4.11	4.11	0.00	0.00	1536/1536	Array#select	101
---
	 	        4.11	4.11	0.00	0.00	1536/1536	Array#each	
61.98%	61.98%	4.11	4.11	0.00	0.00	1536	    Array#select

```

Результат примерно тот же, что и предыдущем случае, но видно, что:

- основное время уходит на `Array#each`, что говорит о том, что затратна сама
  итерация по массиву, а не выполнение проверки условия.
- Четко видно, что наиболее затратная строчка -- та, про которую можно было
  сделать предположение при предыдущем профайлинге:
```ruby
    user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
```

## [x] Построить и проанализировать отчёт ruby-prof в режиме CallStack;
Видим примерно то же самое, что и для Flat:
```
Thread: 260, Fiber: 240 (100.00% ~ 5.872050523001235)
  100.00% (100.00%) Object#profile_using_ruby_prof [1 calls, 1 total]
    100.00% (100.00%) Object#do_work [1 calls, 1 total]
      100.00% (100.00%) Object#work [1 calls, 1 total]
        61.62% (61.62%) Array#each [2 calls, 41 total]
          58.93% (95.64%) Array#select [1536 calls, 1536 total]
```

## [x] Построить и проанализировать отчёт ruby-prof в режиме CallTree c визуализацией в QCachegrind;
Примерно то же, что и для Graph

## [x] Построить дамп stackprof и проанализировать его с помощью CLI
```
==================================
  Mode: wall(1000)
  Samples: 3421 (17.47% miss rate)
  GC: 0 (0.00%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      3421 (100.0%)        3178  (92.9%)     Object#work
       191   (5.6%)         191   (5.6%)     ProgressBar#increment!
       100   (2.9%)          18   (0.5%)     Object#collect_stats_from_users
```
Уточняем метод, точно видим снова проблемное место:
```
$ stackprof report/stackprof.dump --method "Object#work"
Object#work (/Users/dave/dev/rails-optimization-task1/src/work.rb:43)
  samples:  3178 self (92.9%)  /   3421 total (100.0%)
  callers:
    6434  (  188.1%)  Object#work
    3421  (  100.0%)  Object#do_work
      82  (    2.4%)  Object#collect_stats_from_users
  callees (243 total):
    6434  ( 2647.7%)  Object#work
     191  (   78.6%)  ProgressBar#increment!
     100  (   41.2%)  Object#collect_stats_from_users
      15  (    6.2%)  Object#parse_session
      13  (    5.3%)  User#initialize
       5  (    2.1%)  Object#parse_user
       1  (    0.4%)  ProgressBar#initialize
  code:
....
 3014   (88.1%)                   |   100  |   users.each do |user|
                                  |   101  |     attributes = user
 5972  (174.6%) /  2986  (87.3%)  |   102  |     user_sessions = sessions.select { |session| session['user_id'] == user['id'] }
   14    (0.4%) /     1   (0.0%)  |   103  |     user_object = User.new(attributes: attributes, sessions: user_sessions)
                                  |   104  |     users_objects = users_objects + [user_object]
   14    (0.4%) /    14   (0.4%)  |   105  |   end
....
```
## [x] Построить дамп stackprof в json и проанализировать его с помощью speedscope.app
Не удалось увидеть ничего глубже метода `#work`.  Возможно, в слкдующих итерациях будет работоспособнее.
## [ ] Профилировать работающий процесс rbspy; 
Тут все понятно, много использовал.


# Фидебэк-луп

## Итерация 1

> ...TODO

